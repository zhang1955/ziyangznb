# 数据结构知识点

### 绪论1

有关概念和术语

数据元素：(也称为结点)是数据的基本单位

数据对象：是性质相同的数据元素的集合，是数据的一个子集

数据结构：是相互之间存在一种或多种特定的数据元素的集合

要设计出好的非数值计算的程序必须要解决以下问题：理清所处理的数据之间的逻辑关系以及处理要求、数据在计算机中的存储、数据处理的实现

数据结构：

逻辑结构：

线性结构(线性表，栈，队，串，数组)

非线性结构(树结构，图结构)

物理(储存)结构：

顺序结构

链式结构

索引结构

散列结构
数据的逻辑结构有4种：集合、线性(一对一)，树状(一对多)、图状(多对多

)存储结点之间有4种实现方式：顺序(可随机访问，但不易修改)、链接(与顺序相反)、散列存储、索引存储
算法的质量：

1正确性：算法应能正确的实现预定的功能

2易读性：算法应易于阅读和理解，以便调试，修改和扩充

3健壮性：当环境发生变化时，算法能适当地做出反应或进行处理，不会出现不正确的运算结果

4高效性：具有较高的时间(时间复杂度)和空间性能
影响时间复杂度的原因：问题规模和输入数据的分布、编译器生成的目标代码的质量、计算机系统的性能、程序采用算法的优劣

算法的特性：有穷性、确定性(不会产生二义性)、可行性(可有限次实现)、输入输出
时间复杂度的算法：O(1)<O(log2n)<O(n)<O(nlog2n)<O(n^2)<O(n^3)<O(2^n)

注：程序中没for循环就是O(1)，有for循环就是O(n)，for嵌套多少次就是n的多少次方  时间复杂度和空间复杂度是用来评价算法的优劣的

线性表#include <stdio.h>

#define MAXLEN 100      /*定义常量MAXLEN为100表示存储空间总量*/

typedef int DataType;     /*定义ElemType为int类型*

/typedef struct         /*顺序表存储类型*/

{ 

​	 DataType  data[MAXLEN];   /*存放线性表的数组*/ 

​	 int Length;         /*Length是顺序表的长度*/}

SeqList;链表：

#include <stdio.h>

#include <malloc.h>

typedef int DataType;     /*定义DataType为int类型*/

typedef struct linknode    /*单链表存储类型*/

{  

​	DataType    data;     /*定义结点的数据域*/

​	struct linknode  *next;  */*定义结点的指针域*/

} LinkList;

双向链表：  

typedef struct DNode  

 {    ElemType data；

​    struct DNode * prior,*next；  

 }DNode, *DoubleList；

循环队列：

int EmptyQueue (SeqQueue *Q)*

*{  /*判断队空函数*/  

if(Q->frontQ->rear)

​	return 1;  

​		else 

   return 0;

}

int enterQueue(SeqQueue *Q,DataType e)*

*{  /*入队函数*/  

if((Q->rear+1)%MAXSIZEQ->front)

 {  

printf("队满，不能入队元素!"); 

   return 0;  } 

 else  

{

Q->rear=(Q->rear+1)%MAXSIZE;Q->data[Q->rear]=e;

​    return 1;

   }

}

int outQueue(SeqQueue *Q,DataType *e)*

*{  /*出队函数*/ 

if(EmptyQueue(Q))

{printf("队空，不能出队元素!");

​    return 0;

  }

else 

 { Q->front=(Q->front+1)%MAXSIZE;

*e=Q->data[Q->front];

​		return 1;

}

}

三元组矩阵：

将左图所示稀疏矩阵的用右边的三元组矩阵表示 

树和二叉树

树的定义和基本术语根

结点：没有直接前驱的称为根结点

叶结点：没有直接后继的称为叶结点

内部结点：除了根结点和叶结点就是内部结点

结点的度：一个节点的所有后继，二叉树种结点的度最大是2

结点的层次也称为深度

森林：多个互不相交的树的集合

二叉树转化位森林：将左孩子作为第一个儿子，右孩子看出兄弟，反之亦然二叉树

每个结点的度都不大于2每个结点的孩子结点次序不能任意颠倒

满二叉树：每层结点都是满的

完全二叉树：每一层从左到右按顺序排列，最有一层可以不全但不可以有缺失满二叉树必为完全二叉树，而完全二叉树不一定是满二叉树。

性质1：在二叉树的第i层上至多有2^(i-1)^个结点^

^性质2：深度为k的二叉树至多有2^k-1个结点性质3：对任意一棵二叉树T，若终端结点数为n0，而其度数为2的结点数为n2，则n0= n2+1性质4：具有n个结点的完全二叉树深度为log2n+1性质5：序号为i的左孩子是2i，右孩子是2i+1,父是i/2先序遍历二叉树的过程是：访问根结点、先序遍历左子树、先序遍历右子树中序遍历二叉树的过程是：中序遍历左子树、访问根结点、中序遍历右子树后序遍历二叉树的过程是：后序遍历左子树、后序遍历右子树、访问根结点。先序遍历的递归算法：void PreOrder(BiTree bt){  if (bt!=NULL)    {  Visit(bt->data); //printf(“%c”, bt->data)       PreOrder(bt->LChild);       PreOrder(bt->RChild);     }}中序遍历的递归算法：void InOrder(BiTree bt){     if (bt!=NULL)    {    InOrder(root->Lchild）;         Visit(root->data);        InOrder(root->RChild);    }  }后序遍历的递归算法：void PostOrder(BiTree bt) {      if(bt!=NULL)    {  PostOrder(bt->LChild);      PostOrder(bt->RChild);       Visit(bt->data);     }}
权值：（a）、（b）、（c）所示的三棵二叉树，它们的带权路径长度分别为：（a）WPL=2×2+3×2+4×2+6×2=30（b）WPL=2×3+3×3+4×2+6×1=29（c）WPL=4×3+6×3+3×2+2×1=38集合与查找表二叉排序建立：45，24，53，12，28，90时间复杂度为O(nlog2n)。当根结点放好后，后面的数与之比较，小于左放，大于右放。  二叉排序树的删除① 若p是叶子结点： 直接删除p，如图(b)所示。② 若p只有一棵子树(左子树或右子树)：直接用p的左子树(或右子树)取代p的位置而成为f的一棵子树。即原来p是f的左子树，则p的子树成为f的左子树；原来p是f的右子树，则p的子树成为f的右子树③ 若p既有左子树又有右子树 ：处理方法有以下两种，可以任选其中一种。1，用p的直接前驱结点代替p。即从p的左子树中选择值最大的结点s放在p的位置，s是p的左子树中的最右边的结点且没有右子树2，用p的直接后继结点代替p。即从p的右子树中选择值最小的结点s放在p的位置，s是p的右子树中的最左边的结点且没有左子树
平均查找长度(ASL)其中n为查找表中元素个数，Pi为查找第i个元素的概率，通常假设每个元素查找概率相同，Pi=1/n，Ci是找到第i个元素的比较次数。顺序查找的ASL:  ASL成功=n+1/2 ASL不成功=n折半查找(二分查找)： ASL成功=每个结点比较的次数之和/结点数ASL不成功=空指针处比较的次数之和/空指针数二叉排序法：ASL成功=PiKi/N(Pi为查找的概率或次数 Ki为所在的层数 N为所有结点数和)ASL不成功=AB/N(A为每一层空的结点数 B为所在的层数 N所有为空结点数和)(a)ASL成功=1/6(1+2+2+3+3+3)=14/6 ASL不成功=3*1/1=3(b) ASL成功=1/6(1+2+3+4+5+6)=21/6分块查找如果表长为n，本分成m个块，最简分就是当m取根号n，平均查找时间得到最小值根号n +1二叉查找树：左孩子必须比根结点小，右孩子必须比根结点大平衡树(AVL)二叉树：左子树和右子树深度之差的绝对值不大于1解决不平衡的办法：删除一个数字5后单右旋，左旋类似
右双旋、左双旋类似散列表(哈希表)五种方法：数字分析法、平方取中法、分段叠加法、除留余数法、伪随机数法解决冲突的三种闭散列表方法：再散列法(链地址法)、二次探测法、线性探测法一张解决冲突的开散列表方法：开散列法填装因子α=哈希表中元素个数 / 哈希表的长度排序图基本定义结点的度：与该节点关联的边数，有向图又出度和入度之分。简单回路：环或者回路连通图：任意两个结点之间都是连通的连通分量：极大的连通子图完全图：1无向图：最多有n(n-1)/2条边，2有向图：最多有n(n-1)条边生成树：包含图的所有结点，但只有n-1条边深度优先搜索：类似于树的前序遍历，(一条路走到黑)广度优先搜索：类似于树的层次遍历，(四处撒花)拓扑排序(AOV)：就是把有向无环图按一定要求排序关键路径(AOE)：从源点开始到收点为止的最长的路径关键活动：关键路径上的活动最小生成树：Kruskal算法：从边的角度出发，Prim算法：从顶点的角度出发。